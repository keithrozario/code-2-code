{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "Update User Model and Create Database Migration",
        "description": "Modify the SQLAlchemy User model in `moneynote/models/user.py` to include the necessary fields for account binding and initial state. The model must include `username` (String, unique), `hashed_password` (String, nullable), `invite_code` (String, nullable), `default_book_id` (Integer, FK), and `default_group_id` (Integer, FK). After updating the model, generate a new Alembic migration script to apply these changes to the database schema.",
        "details": "File to modify: `moneynote/models/user.py`. Command to run: `alembic revision --autogenerate -m 'add fields for user binding and defaults'`. Ensure the `username` column has a unique constraint. The `hashed_password` and `invite_code` should be nullable to support invited/temporary users who haven't bound their accounts yet.",
        "testStrategy": "Review the generated migration script to ensure it correctly adds the new columns with the right types, constraints, and foreign key relationships. Apply the migration to a test database and inspect the `t_user` table schema to confirm the changes.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add User Identification Fields to User Model",
            "description": "Modify the `User` class in `moneynote/models/user.py` to include fields for user identification and authentication. Add `username`, `hashed_password`, and `invite_code`.",
            "dependencies": [],
            "details": "In `moneynote/models/user.py`, add the following SQLAlchemy columns to the `User` model: `username` as a `String(100)` with `unique=True` and `index=True`; `hashed_password` as a `String` that is `nullable=True`; and `invite_code` as a `String` that is also `nullable=True` and has an `index=True`.",
            "status": "pending",
            "testStrategy": "Code review to ensure the columns are added with the correct types and constraints as specified."
          },
          {
            "id": 2,
            "title": "Add Foreign Key Columns for Default Book and Group",
            "description": "Extend the `User` model in `moneynote/models/user.py` to include foreign key columns for `default_book_id` and `default_group_id`.",
            "dependencies": [
              "11.1"
            ],
            "details": "In `moneynote/models/user.py`, add `default_book_id` as an `Integer` with a `ForeignKey('t_book.id')` and `nullable=True`. Similarly, add `default_group_id` as an `Integer` with a `ForeignKey('t_group.id')` and `nullable=True`. Ensure `Integer` and `ForeignKey` are imported from `sqlalchemy`.",
            "status": "pending",
            "testStrategy": "Code review to confirm the foreign key columns are correctly defined and point to the `t_book` and `t_group` tables."
          },
          {
            "id": 3,
            "title": "Establish ORM Relationships for Defaults",
            "description": "Define the SQLAlchemy ORM relationships in the `User` model to easily access the related `Book` and `Group` objects.",
            "dependencies": [
              "11.2"
            ],
            "details": "In `moneynote/models/user.py`, import `relationship` from `sqlalchemy.orm`. Add two relationship attributes to the `User` class: `default_book = relationship('Book')` and `default_group = relationship('Group')`. This will link the foreign keys to the corresponding ORM models.",
            "status": "pending",
            "testStrategy": "Code review to ensure the relationships are correctly configured, allowing for ORM-based access to the default book and group."
          },
          {
            "id": 4,
            "title": "Generate Alembic Migration Script",
            "description": "Use Alembic to automatically generate a new migration script based on the changes made to the `User` model.",
            "dependencies": [
              "11.3"
            ],
            "details": "After saving the changes to `moneynote/models/user.py`, run the following command from the project root: `alembic revision --autogenerate -m 'add fields for user binding and defaults'`. This will create a new file in the `alembic/versions/` directory.",
            "status": "pending",
            "testStrategy": "Verify that a new migration file is created in `alembic/versions/` and that the command executes without errors."
          },
          {
            "id": 5,
            "title": "Review and Verify Generated Migration Script",
            "description": "Manually inspect the newly generated Alembic migration script to ensure it accurately reflects all the model changes.",
            "dependencies": [
              "11.4"
            ],
            "details": "Open the new migration file in `alembic/versions/`. In the `upgrade()` function, verify the presence of `op.add_column()` for `username`, `hashed_password`, `invite_code`, `default_book_id`, and `default_group_id`. Confirm that `op.create_unique_constraint()` is present for the `username` column and that `op.create_foreign_key()` is defined for both `default_book_id` and `default_group_id`. Check that the `downgrade()` function correctly reverses these changes.",
            "status": "pending",
            "testStrategy": "A thorough manual review of the generated script against the requirements. Applying the migration to a test database and inspecting the `t_user` table schema is the final verification step."
          }
        ]
      },
      {
        "id": 12,
        "title": "Implement Password Hashing Utility",
        "description": "Create a password utility module, likely in `moneynote/security.py`, to handle password hashing and verification. This module should provide at least two functions: `hash_password(password)` which returns a bcrypt hash of the input string, and `verify_password(plain_password, hashed_password)` which returns a boolean.",
        "details": "Install the `passlib` library with bcrypt support (`pip install 'passlib[bcrypt]'`). Implement the functions in `moneynote/security.py`. This utility will be used by the `/bind` endpoint's service logic to securely store user passwords.",
        "testStrategy": "Write unit tests for the password utility. Test that `hash_password` produces a valid hash. Test that `verify_password` correctly returns `true` for a correct password and `false` for an incorrect one.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add `passlib[bcrypt]` to Project Dependencies",
            "description": "Update the project's dependency file, `requirements.txt`, to include `passlib` with bcrypt support. This ensures the library is installed as part of the standard project setup and is available for the application.",
            "dependencies": [],
            "details": "Based on the project structure, dependency management is handled via `requirements.txt`. Add the line `passlib[bcrypt]` to this file. After updating, developers should run `pip install -r requirements.txt` to install the new dependency in their local environment.",
            "status": "pending",
            "testStrategy": "Verify the dependency is installed correctly by running `pip freeze | grep passlib` in the virtual environment."
          },
          {
            "id": 2,
            "title": "Create `moneynote/security.py` and Configure `CryptContext`",
            "description": "Create the new module file `moneynote/security.py`. In this file, import `CryptContext` from `passlib.context` and instantiate a configured context for bcrypt hashing.",
            "dependencies": [
              "12.1"
            ],
            "details": "Analysis shows this file does not yet exist. Create `moneynote/security.py`. Add the following code to initialize the hashing context: `from passlib.context import CryptContext` followed by `pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")`. This shared context object will be used by the hashing and verification functions.",
            "status": "pending",
            "testStrategy": "N/A (This is a setup task; its correctness will be verified by subsequent subtasks)."
          },
          {
            "id": 3,
            "title": "Implement the `hash_password` Function",
            "description": "In `moneynote/security.py`, create the `hash_password` function that generates a bcrypt hash from a plain-text password string.",
            "dependencies": [
              "12.2"
            ],
            "details": "Define the function `def hash_password(password: str) -> str:`. Inside the function, use the `pwd_context.hash()` method with the provided password argument. The function should return the resulting hashed string.",
            "status": "pending",
            "testStrategy": "Unit tests in subtask 12.5 will cover this function's output."
          },
          {
            "id": 4,
            "title": "Implement the `verify_password` Function",
            "description": "In `moneynote/security.py`, create the `verify_password` function that securely compares a plain-text password with a previously generated bcrypt hash.",
            "dependencies": [
              "12.2"
            ],
            "details": "Define the function `def verify_password(plain_password: str, hashed_password: str) -> bool:`. This function should use the `pwd_context.verify()` method, passing the plain password and the hashed password. It must return the boolean result of the verification.",
            "status": "pending",
            "testStrategy": "Unit tests in subtask 12.5 will validate both true and false return values."
          },
          {
            "id": 5,
            "title": "Create Unit Tests for Password Utilities",
            "description": "Create a new test file, `tests/test_security.py`, to write unit tests for the `hash_password` and `verify_password` functions to ensure their correctness and reliability.",
            "dependencies": [
              "12.3",
              "12.4"
            ],
            "details": "In `tests/test_security.py`, import the `hash_password` and `verify_password` functions. Create a test case that: 1. Hashes a sample password. 2. Asserts that `verify_password` returns `True` for the correct password and the generated hash. 3. Asserts that `verify_password` returns `False` for an incorrect password and the generated hash.",
            "status": "pending",
            "testStrategy": "Follow the existing testing patterns in the `tests/` directory. Use the `pytest` framework to define and run the tests."
          }
        ]
      },
      {
        "id": 13,
        "title": "Define Pydantic Schemas for User Session Endpoints",
        "description": "Create the necessary Pydantic schemas in `moneynote/schemas/user.py` to support the new endpoints. This includes a request schema for `/bind` and response schemas for `/initState`.",
        "details": "1. Create `UserBind(BaseModel)` with fields: `username: str`, `password: str`, `inviteCode: str`. 2. Create `InitStateUser(BaseModel)`, `InitStateBook(BaseModel)`, and `InitStateGroup(BaseModel)` to model the nested objects in the `/initState` response, based on the `UserSessionVo`, `BookSessionVo`, and `GroupSessionVo` concepts. 3. Create a main `InitStateResponse(BaseModel)` schema containing `user: InitStateUser`, `book: Optional[InitStateBook]`, and `group: Optional[InitStateGroup]`.",
        "testStrategy": "These schemas will be implicitly tested by the endpoint integration tests. Ensure they correctly validate incoming data for `/bind` and serialize the outgoing data for `/initState`.",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create `user.py` schema file and add base imports",
            "description": "Create a new file `moneynote/schemas/user.py` and add the necessary base imports from `pydantic` and `typing` that will be used by all schemas in this file.",
            "dependencies": [],
            "details": "Create the file `moneynote/schemas/user.py`. Add the following imports at the top of the file: `from typing import Optional` and `from pydantic import BaseModel`.",
            "status": "pending",
            "testStrategy": "This subtask is foundational and will be implicitly verified by the successful implementation of subsequent subtasks."
          },
          {
            "id": 2,
            "title": "Define the `UserBind` request schema",
            "description": "In `moneynote/schemas/user.py`, define the Pydantic schema for the `/bind` endpoint's request body.",
            "dependencies": [
              "13.1"
            ],
            "details": "Create a class `UserBind(BaseModel)` with the following fields: `username: str`, `password: str`, and `inviteCode: str`. This schema will be used to validate the incoming data for user binding.",
            "status": "pending",
            "testStrategy": "The schema will be tested during the integration testing of the `/bind` endpoint to ensure it correctly validates request bodies."
          },
          {
            "id": 3,
            "title": "Define the `InitStateUser` response schema",
            "description": "In `moneynote/schemas/user.py`, define the Pydantic schema for the user object within the `/initState` response, based on the `User` ORM model.",
            "dependencies": [
              "13.1"
            ],
            "details": "Create a class `InitStateUser(BaseModel)`. Based on the `moneynote/models/user.py` model, add the fields `id: int`, `username: str`, `nickname: Optional[str]`, and `avatar: Optional[str]`. Add an inner `class Config` with `orm_mode = True` to enable mapping from the SQLAlchemy model.",
            "status": "pending",
            "testStrategy": "This schema's correctness will be verified by the integration tests for the `/initState` endpoint, ensuring user data is serialized correctly."
          },
          {
            "id": 4,
            "title": "Define `InitStateBook` and `InitStateGroup` response schemas",
            "description": "In `moneynote/schemas/user.py`, define the Pydantic schemas for the optional book and group objects within the `/initState` response.",
            "dependencies": [
              "13.1"
            ],
            "details": "Create `class InitStateBook(BaseModel)` with fields `id: int` and `name: str`. Create `class InitStateGroup(BaseModel)` with fields `id: int` and `name: str`. For both schemas, add an inner `class Config` with `orm_mode = True` to support ORM model mapping.",
            "status": "pending",
            "testStrategy": "These schemas will be tested as part of the `/initState` endpoint integration tests, covering cases where book and group data are present."
          },
          {
            "id": 5,
            "title": "Define `InitStateResponse` schema and export all new schemas",
            "description": "Create the main `InitStateResponse` schema that composes the user, book, and group schemas. Then, export all newly created schemas from the `moneynote.schemas` package.",
            "dependencies": [
              "13.3",
              "13.4"
            ],
            "details": "In `moneynote/schemas/user.py`, create `class InitStateResponse(BaseModel)` with fields `user: InitStateUser`, `book: Optional[InitStateBook]`, and `group: Optional[InitStateGroup]`. Afterwards, edit `moneynote/schemas/__init__.py` to import and add `UserBind`, `InitStateUser`, `InitStateBook`, `InitStateGroup`, and `InitStateResponse` to the `__all__` list.",
            "status": "pending",
            "testStrategy": "The top-level schema will be validated by the `/initState` endpoint's integration tests. The package export will be verified by ensuring the schemas can be imported correctly in the endpoint implementation."
          }
        ]
      },
      {
        "id": 14,
        "title": "Enhance User CRUD Operations for Binding",
        "description": "Update `moneynote/crud/crud_user.py` with functions required by the user binding service. Add `get_by_username` to check for username conflicts and modify the existing `update` function or create a new one to specifically handle setting the `username` and `hashed_password`.",
        "details": "1. Implement `get_by_username(db: Session, *, username: str) -> Optional[models.User]`. 2. Ensure an update function exists that can take a user object and a dictionary of update data to modify the user record in the database. This will be used to persist the new username and hashed password.",
        "testStrategy": "Write unit tests for the new `get_by_username` function. Test cases should include finding an existing user and attempting to find a non-existent user.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `get_by_username` Method in `CRUDUser` Class",
            "description": "In `moneynote/crud/crud_user.py`, add a new method `get_by_username` to the `CRUDUser` class. This method is required to check for username availability before binding an account.",
            "dependencies": [],
            "details": "The function signature must be `def get_by_username(self, db: Session, *, username: str) -> Optional[models.User]:`. It should query the database for a user with the matching username, leveraging the `User` model from `moneynote/models/user.py`. The implementation should be similar to the existing `get_by_email` method.",
            "status": "pending",
            "testStrategy": "A subsequent subtask will cover unit testing for this new method."
          },
          {
            "id": 2,
            "title": "Verify and Document `update` Method for User Binding",
            "description": "Confirm that the existing `update` method in `CRUDUser` (likely inherited from `CRUDBase`) can be used to set the `username` and `hashed_password` fields and add a clarifying code comment.",
            "dependencies": [],
            "details": "Examine the `update` method in `moneynote/crud/base.py` to ensure it can process a dictionary containing `username` and `hashed_password`. No code changes are needed if the generic implementation is sufficient. Add a comment in `moneynote/crud/crud_user.py` above the `CRUDUser` class instantiation, noting that the generic `update` method is used to persist binding information.",
            "status": "pending",
            "testStrategy": "A unit test will be created in a later subtask to formally verify this functionality."
          },
          {
            "id": 3,
            "title": "Add Unit Test for `get_by_username` Success Case",
            "description": "In the appropriate test file (e.g., `tests/crud/test_crud_user.py`), write a unit test to verify that `crud.user.get_by_username` successfully retrieves an existing user.",
            "dependencies": [
              "14.1"
            ],
            "details": "The test should first create a user with a specific username in the test database. Then, it must call `crud.user.get_by_username` with that same username and assert that the returned object is not `None` and that its `username` attribute matches the one created.",
            "status": "pending",
            "testStrategy": "This test covers the 'happy path' scenario for the `get_by_username` function."
          },
          {
            "id": 4,
            "title": "Add Unit Test for `get_by_username` with Non-Existent User",
            "description": "Write a unit test to ensure `crud.user.get_by_username` returns `None` when a username that does not exist in the database is provided.",
            "dependencies": [
              "14.1"
            ],
            "details": "In `tests/crud/test_crud_user.py`, call `crud.user.get_by_username` using a username string that is guaranteed not to be in the test database. The test must assert that the function's return value is `None`.",
            "status": "pending",
            "testStrategy": "This test covers the 'failure path' or 'not found' scenario for the `get_by_username` function."
          },
          {
            "id": 5,
            "title": "Add Unit Test for Updating User's Binding Information",
            "description": "Create a unit test to confirm that the `update` method correctly sets a user's `username` and `hashed_password`.",
            "dependencies": [
              "14.2"
            ],
            "details": "In `tests/crud/test_crud_user.py`, create a test user. Call `crud.user.update` with the user object and a dictionary containing new values for `username` and `hashed_password`. After the operation, re-fetch the user from the database and assert that the `username` and `hashed_password` fields have been successfully changed to the new values.",
            "status": "pending",
            "testStrategy": "This test provides concrete validation for the `update` functionality that was reviewed in subtask 2."
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement `bind_user` Service Logic",
        "description": "In `moneynote/services/user_service.py`, create the `bind_user` function. This function will contain the core business logic for the `PUT /bind` endpoint.",
        "details": "The function signature should be `bind_user(db: Session, *, current_user: models.User, bind_data: schemas.UserBind)`. The logic should: 1. Use `crud_user.get_by_username` to check if the desired username is already taken; raise `HTTPException` if so. 2. Verify that `current_user.invite_code` matches `bind_data.inviteCode`; raise `HTTPException` if not. 3. Use the password utility from task 12 to hash `bind_data.password`. 4. Use `crud_user.update` to save the new `username` and `hashed_password` to the `current_user`'s record.",
        "testStrategy": "Write unit tests for the `bind_user` service function using a mocked database session and user objects. Test the success path, username conflict scenario, and invalid invite code scenario.",
        "priority": "high",
        "dependencies": [
          12,
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define `bind_user` function and add imports",
            "description": "In `moneynote/services/user_service.py`, define the function signature for `bind_user` and add all necessary imports for its implementation.",
            "dependencies": [],
            "details": "Add the function `def bind_user(db: Session, *, current_user: models.User, bind_data: schemas.UserBind) -> models.User:` to `moneynote/services/user_service.py`. Ensure the following imports are present: `from fastapi import HTTPException`, `from sqlalchemy.orm import Session`, `from moneynote import models, schemas`, `from moneynote.crud import crud_user`, and `from moneynote.security import hash_password`. The function body can be a `pass` statement initially.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement username conflict check",
            "description": "Add logic to the `bind_user` function to check if the desired username is already in use.",
            "dependencies": [
              "15.1"
            ],
            "details": "Within the `bind_user` function, call `crud_user.get_by_username(db, username=bind_data.username)`. If this call returns a user object, it means the username is taken. In this case, raise an `HTTPException` with `status_code=400` and a detail message like 'Username already registered'.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement invite code verification",
            "description": "Add logic to the `bind_user` function to verify the provided invite code against the current user's code.",
            "dependencies": [
              "15.1"
            ],
            "details": "Inside the `bind_user` function, compare `current_user.invite_code` with `bind_data.inviteCode`. If they do not match, raise an `HTTPException` with `status_code=400` and a detail message like 'Invalid invite code'.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Hash the new password",
            "description": "Use the password hashing utility to securely hash the password from the request data.",
            "dependencies": [
              "15.1"
            ],
            "details": "Call the `hash_password` function from `moneynote.security` with `bind_data.password` as the argument. Store the returned hashed password in a variable, e.g., `hashed_password`.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Update user record in the database",
            "description": "Use the CRUD layer to update the user's record with the new username and hashed password, and return the updated user.",
            "dependencies": [
              "15.2",
              "15.3",
              "15.4"
            ],
            "details": "Create a dictionary `update_data = {'username': bind_data.username, 'hashed_password': hashed_password}`. Call `crud_user.update(db, db_obj=current_user, obj_in=update_data)`. Return the result of this call, which will be the updated `models.User` object.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 16,
        "title": "Implement `PUT /bind` Endpoint in Router",
        "description": "Add the `PUT /bind` endpoint to the user router located at `moneynote/routers/users.py`. This endpoint will wire together the request, authentication dependency, and the service logic.",
        "details": "Define a new path operation decorator `@router.put('/bind', status_code=200)`. The function will take the request body `bind_data: schemas.UserBind`, the database session dependency, and the current user dependency `current_user: models.User = Depends(deps.get_current_user)`. It will call the `user_service.bind_user` function with the appropriate arguments and handle any exceptions thrown by the service layer.",
        "testStrategy": "Write an integration test for the `PUT /bind` endpoint. Use `TestClient` to make requests with a valid JWT. Test the happy path (TC-P2-01), username conflict (TC-P2-02), and invalid invite code (TC-P2-03) scenarios.",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Import Required Schemas and Models in users.py",
            "description": "In `moneynote/routers/users.py`, ensure all necessary modules are imported to support the new endpoint. Specifically, import `models` and the `UserBind` schema from `moneynote.schemas`.",
            "dependencies": [],
            "details": "Add or verify the following imports at the top of `moneynote/routers/users.py`:\n\n```python\nfrom moneynote import models, schemas\n```\n\nThis will make `models.User` and `schemas.UserBind` available for type hinting in the new endpoint function.",
            "status": "pending",
            "testStrategy": "Code review to ensure the imports are present before implementing the endpoint function."
          },
          {
            "id": 2,
            "title": "Define the Path Operation Decorator for PUT /bind",
            "description": "In `moneynote/routers/users.py`, add the path operation decorator for the new endpoint. This will define the HTTP method, path, success status code, and the response model.",
            "dependencies": [],
            "details": "Based on existing endpoints like `/pre-regist`, the new endpoint should return the updated user object. Add the following decorator above the new endpoint function:\n\n```python\n@router.put('/bind', response_model=schemas.User, status_code=200)\n```\n\nThis sets the endpoint to handle `PUT` requests to `/bind`, return a `200 OK` status on success, and serialize the response using the `schemas.User` model.",
            "status": "pending",
            "testStrategy": "This will be tested as part of the overall endpoint integration test."
          },
          {
            "id": 3,
            "title": "Define the Endpoint Function Signature",
            "description": "In `moneynote/routers/users.py`, define the function for the `/bind` endpoint with the correct parameters and dependencies as specified in the task.",
            "dependencies": [
              "16.1",
              "16.2"
            ],
            "details": "Create an `async def` function named `bind_user_account`. The function signature must include the request body, the database session dependency, and the current user dependency.\n\n```python\nasync def bind_user_account(\n    *, \n    db: Session = Depends(deps.get_db),\n    bind_data: schemas.UserBind,\n    current_user: models.User = Depends(deps.get_current_user)\n):\n    # Function body will be implemented in subsequent subtasks\n    pass\n```\nNote: The request body `bind_data` does not need `Depends()` as FastAPI handles Pydantic models in the body automatically. Placing it after the dependencies with default values requires making it a keyword-only argument (`*`).",
            "status": "pending",
            "testStrategy": "Code review to ensure the function signature matches the requirements."
          },
          {
            "id": 4,
            "title": "Implement the Service Layer Call",
            "description": "Inside the `bind_user_account` function, call the `user_service.bind_user` function, passing the required arguments from the endpoint's context.",
            "dependencies": [
              "16.3"
            ],
            "details": "The core logic of the endpoint is to delegate to the service layer. Call `user_service.bind_user` and store its return value. The service function is expected to handle business logic and raise `HTTPException` on errors, which FastAPI will automatically process.\n\n```python\n# Inside bind_user_account function\nupdated_user = user_service.bind_user(\n    db=db, \n    current_user=current_user, \n    bind_data=bind_data\n)\n```",
            "status": "pending",
            "testStrategy": "This logic will be validated by integration tests that mock the service call or test the full flow."
          },
          {
            "id": 5,
            "title": "Add Docstring and Return the Result",
            "description": "Complete the `bind_user_account` function by adding a descriptive docstring and returning the result from the service layer call.",
            "dependencies": [
              "16.4"
            ],
            "details": "Add a Python docstring to explain the purpose of the endpoint. The function should return the `updated_user` object obtained from the service call, which FastAPI will then process using the `response_model` defined in the decorator.\n\n```python\n# Inside moneynote/routers/users.py\n\nasync def bind_user_account(...):\n    \"\"\"\n    Bind username and password for a pre-registered user.\n    \"\"\"\n    updated_user = user_service.bind_user(\n        db=db, \n        current_user=current_user, \n        bind_data=bind_data\n    )\n    return updated_user\n```",
            "status": "pending",
            "testStrategy": "Run the integration tests for the happy path (TC-P2-01) to verify that a valid request receives a `200 OK` response with the updated user data."
          }
        ]
      },
      {
        "id": 17,
        "title": "Implement `get_initial_state` Service Logic",
        "description": "In `moneynote/services/user_service.py`, create the `get_initial_state` function. This function will fetch and aggregate the data required for the `GET /initState` endpoint.",
        "details": "The function signature should be `get_initial_state(db: Session, *, current_user: models.User) -> schemas.InitStateResponse`. The logic should: 1. Get the `current_user` object. 2. If `current_user.default_book_id` is not null, fetch the corresponding book using `crud_book.get`. 3. If `current_user.default_group_id` is not null, fetch the corresponding group using `crud_group.get`. 4. Assemble the user, book (or null), and group (or null) data into an `InitStateResponse` schema object and return it.",
        "testStrategy": "Write unit tests for the `get_initial_state` service function. Test the case where a user has both a default book and group, and the boundary case where one or both are null (TC-P2-05).",
        "priority": "high",
        "dependencies": [
          11,
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define `get_initial_state` Function and Add Imports",
            "description": "In `moneynote/services/user_service.py`, add the necessary imports and define the function skeleton for `get_initial_state`.",
            "dependencies": [],
            "details": "Import `Session` from `sqlalchemy.orm`, and `models`, `schemas`, `crud` from the `moneynote` package. Then, define the function with the correct signature: `def get_initial_state(db: Session, *, current_user: models.User) -> schemas.InitStateResponse:`. Use a `pass` statement for the initial implementation.",
            "status": "pending",
            "testStrategy": "Verify the file is syntactically correct and the application still runs after adding the empty function."
          },
          {
            "id": 2,
            "title": "Implement Default Book Fetching Logic",
            "description": "Inside the `get_initial_state` function, add the logic to fetch the user's default book if one is set.",
            "dependencies": [
              "17.1"
            ],
            "details": "Initialize a variable `book = None`. Check if `current_user.default_book_id` is not None. If it's set, call `crud.book.get(db=db, id=current_user.default_book_id)` and assign its return value to the `book` variable. The `crud.book` object is available via the `crud` import.",
            "status": "pending",
            "testStrategy": "In a unit test context, mock `crud.book.get` and verify it's called with the correct `id` when `default_book_id` is present on the user object."
          },
          {
            "id": 3,
            "title": "Implement Default Group Fetching Logic",
            "description": "Inside the `get_initial_state` function, add the logic to fetch the user's default group if one is set.",
            "dependencies": [
              "17.1"
            ],
            "details": "Initialize a variable `group = None`. Check if `current_user.default_group_id` is not None. If it's set, call `crud.group.get(db=db, id=current_user.default_group_id)` and assign its return value to the `group` variable. The `crud.group` object is available via the `crud` import.",
            "status": "pending",
            "testStrategy": "In a unit test context, mock `crud.group.get` and verify it's called with the correct `id` when `default_group_id` is present on the user object."
          },
          {
            "id": 4,
            "title": "Assemble and Return `InitStateResponse`",
            "description": "Construct the final `schemas.InitStateResponse` object using the fetched data and return it.",
            "dependencies": [
              "17.2",
              "17.3"
            ],
            "details": "At the end of the `get_initial_state` function, create and return an instance of `schemas.InitStateResponse`. Pass the `current_user`, the `book` variable, and the `group` variable to the schema's constructor, like so: `return schemas.InitStateResponse(user=current_user, book=book, group=group)`.",
            "status": "pending",
            "testStrategy": "Unit test the function's return value. Check that the returned object is an instance of `InitStateResponse` and that its `user`, `book`, and `group` attributes match the mock data provided."
          },
          {
            "id": 5,
            "title": "Add Docstrings and Final Review",
            "description": "Add a comprehensive docstring to the `get_initial_state` function and perform a final review of the implementation.",
            "dependencies": [
              "17.4"
            ],
            "details": "Write a clear docstring for the `get_initial_state` function explaining its purpose, arguments (`db`, `current_user`), and return value. Review the complete function to ensure it matches the requirements, follows project conventions, and is clean and readable.",
            "status": "pending",
            "testStrategy": "Perform a static code analysis or peer review to ensure documentation and code quality standards are met."
          }
        ]
      },
      {
        "id": 18,
        "title": "Implement `GET /initState` Endpoint in Router",
        "description": "Add the `GET /initState` endpoint to the user router at `moneynote/routers/users.py`. This endpoint will provide the consolidated initial state to the frontend.",
        "details": "Define a new path operation decorator `@router.get('/initState', response_model=schemas.InitStateResponse)`. The function will depend on the database session and the current user (`current_user: models.User = Depends(deps.get_current_user)`). It will call the `user_service.get_initial_state` function and return the result.",
        "testStrategy": "Write an integration test for the `GET /initState` endpoint. Use `TestClient` to make requests with a valid JWT. Test the happy path (TC-P2-04), the case with null defaults (TC-P2-05), and the unauthorized case with an invalid token (TC-P2-06).",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Verify and Add Imports in `moneynote/routers/users.py`",
            "description": "Open `moneynote/routers/users.py` and ensure all necessary modules for the new endpoint are imported. Based on existing patterns, this includes `Session` from `sqlalchemy.orm`, `Depends` from `fastapi`, and the project-specific `schemas`, `models`, `dependencies as deps`, and `services` modules.",
            "dependencies": [],
            "details": "Check the top of `moneynote/routers/users.py` for `from fastapi import APIRouter, Depends`, `from sqlalchemy.orm import Session`, and `from .. import schemas, models, dependencies as deps, services`. These imports are likely present but must be confirmed before proceeding.",
            "status": "pending",
            "testStrategy": "N/A"
          },
          {
            "id": 2,
            "title": "Add Path Operation Decorator for `GET /initState`",
            "description": "In `moneynote/routers/users.py`, add the FastAPI path operation decorator for the new endpoint. The decorator should define the HTTP method (`GET`), path (`/initState`), and the expected response model.",
            "dependencies": [
              "18.1"
            ],
            "details": "Add the following decorator above the new endpoint function: `@router.get('/initState', response_model=schemas.InitStateResponse)`.",
            "status": "pending",
            "testStrategy": "N/A"
          },
          {
            "id": 3,
            "title": "Define the Endpoint Function Signature",
            "description": "Below the new decorator in `moneynote/routers/users.py`, define the endpoint function. The function signature must declare dependencies for the database session and the current authenticated user, following the established pattern in the file.",
            "dependencies": [
              "18.2"
            ],
            "details": "Define the function signature as: `def get_user_initial_state(db: Session = Depends(deps.get_db), current_user: models.User = Depends(deps.get_current_user)) -> schemas.InitStateResponse:`.",
            "status": "pending",
            "testStrategy": "N/A"
          },
          {
            "id": 4,
            "title": "Implement Service Layer Call within the Endpoint",
            "description": "Inside the `get_user_initial_state` function, call the `get_initial_state` function from the user service module. Pass the database session and current user object obtained from the dependencies as arguments.",
            "dependencies": [
              "18.3"
            ],
            "details": "Add the following line inside the function: `initial_state = services.user_service.get_initial_state(db=db, current_user=current_user)`. This assumes the `services` module is imported and contains `user_service`.",
            "status": "pending",
            "testStrategy": "This logic will be tested via the integration test for the whole endpoint."
          },
          {
            "id": 5,
            "title": "Return the Service Response from the Endpoint",
            "description": "Complete the endpoint implementation by returning the `InitStateResponse` object that was received from the service layer call. This will be serialized automatically by FastAPI according to the `response_model`.",
            "dependencies": [
              "18.4"
            ],
            "details": "Add the final line to the function: `return initial_state`.",
            "status": "pending",
            "testStrategy": "The integration test for TC-P2-04 will verify that the correct and complete `InitStateResponse` object is returned."
          }
        ]
      },
      {
        "id": 19,
        "title": "Update API Documentation",
        "description": "Update the project's API documentation to reflect the new `PUT /bind` and `GET /initState` endpoints. FastAPI's automatic OpenAPI/Swagger documentation should be regenerated and reviewed.",
        "details": "Ensure the Pydantic schemas and endpoint docstrings in `moneynote/routers/users.py` are clear and descriptive. Add summaries and descriptions to the path operation decorators. Once the code is running, access the `/docs` URL to verify that the documentation correctly describes the request bodies, responses, status codes, and security requirements for both endpoints.",
        "testStrategy": "Manual verification by running the application and navigating to the auto-generated Swagger UI at `/docs`. Check that all parameters, request bodies, and response models for `/bind` and `/initState` are accurately represented.",
        "priority": "low",
        "dependencies": [
          16,
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Documentation to `PUT /bind` Endpoint",
            "description": "Update the `bind_user_account` function in `moneynote/routers/users.py` to include comprehensive documentation. This involves adding a summary and description to the `@router.put` decorator and writing a clear docstring for the function.",
            "dependencies": [],
            "details": "In `moneynote/routers/users.py`, locate the `@router.put(\"/bind\", ...)` decorator. Add `summary` and `description` parameters. The summary should be a short phrase like \"Bind Username to User Account\". The description should explain that this endpoint is used for temporary or invited users to set their permanent username and password. Also, add a Python docstring to the `bind_user_account` function explaining its purpose, arguments, and what it returns.",
            "status": "pending",
            "testStrategy": "After implementation, run the app and check the `/docs` page to see if the summary, description, and docstring appear correctly for the `PUT /bind` endpoint."
          },
          {
            "id": 2,
            "title": "Enhance `UserBind` Pydantic Schema Documentation",
            "description": "Improve the clarity of the `UserBind` schema in `moneynote/schemas/user.py` by adding descriptions to its fields. This will make the request body in the auto-generated documentation more understandable.",
            "dependencies": [],
            "details": "In `moneynote/schemas/user.py`, modify the `UserBind` class. Import `Field` from `pydantic`. Change the field definitions from `username: str` to `username: str = Field(..., description=\"The permanent username to be assigned to the user.\")` and similarly for the `password` field, providing a clear description for each.",
            "status": "pending",
            "testStrategy": "Navigate to the `/docs` page, expand the `PUT /bind` endpoint, and check the 'Request body' section. The `username` and `password` fields in the example and schema should now display the descriptions you added."
          },
          {
            "id": 3,
            "title": "Add Documentation to `GET /initState` Endpoint",
            "description": "Update the `get_init_state` function in `moneynote/routers/users.py` with a descriptive summary, description, and docstring to clarify its purpose in the API documentation.",
            "dependencies": [],
            "details": "In `moneynote/routers/users.py`, find the `@router.get(\"/initState\", ...)` decorator. Add a `summary` like \"Get Initial Application State\" and a `description` explaining that this endpoint provides a consolidated set of data (user info, books, groups) required for the frontend to initialize after login. Add a Python docstring to the `get_init_state` function detailing its behavior.",
            "status": "pending",
            "testStrategy": "Run the application and view the `/docs` UI. Verify that the `GET /initState` endpoint now has the new summary and description. Check that the function's docstring is also visible."
          },
          {
            "id": 4,
            "title": "Enhance `InitStateResponse` Pydantic Schema Documentation",
            "description": "Add field-level descriptions to the `InitStateResponse` schema in `moneynote/schemas/user.py` to document the structure of the data returned by the `/initState` endpoint.",
            "dependencies": [],
            "details": "In `moneynote/schemas/user.py`, locate the `InitStateResponse` class. Import `Field` from `pydantic` if not already present. For each field (`user`, `default_book`, `default_group`, `books`, `groups`), add a `Field` with a `description` explaining what that part of the payload represents. For example, for `user`, the description could be \"The details of the currently authenticated user.\"",
            "status": "pending",
            "testStrategy": "Go to the `/docs` page, expand the `GET /initState` endpoint, and look at the 'Responses' section. The schema for the `200` response should now show the detailed descriptions for each field in the `InitStateResponse` model."
          },
          {
            "id": 5,
            "title": "Add and Verify Status Code Responses",
            "description": "Explicitly document the possible HTTP status code responses for both the `/bind` and `/initState` endpoints, including success and error cases like 401 Unauthorized or 409 Conflict.",
            "dependencies": [
              "19.1",
              "19.3"
            ],
            "details": "In `moneynote/routers/users.py`, add the `responses` parameter to the decorators for both `PUT /bind` and `GET /initState`. For `/bind`, document potential `409 Conflict` (username already exists) and `401 Unauthorized` responses. For `/initState`, document the `401 Unauthorized` response. This provides a more complete API contract for consumers. Example: `responses={409: {\"description\": \"Username already taken\"}}`.",
            "status": "pending",
            "testStrategy": "After adding the `responses` parameter, restart the application and refresh the `/docs` page. Verify that under the 'Responses' section for both endpoints, the newly documented status codes (e.g., 401, 409) and their descriptions are now listed in addition to the default 200 and 422 responses."
          }
        ]
      },
      {
        "id": 20,
        "title": "Consolidate and Finalize Test Suite",
        "description": "Review and consolidate all unit and integration tests written for the user session and initialization features. Ensure the test suite provides comprehensive coverage for all new logic and endpoints.",
        "details": "Organize tests in `tests/routers/test_users.py` and other relevant test files. Make sure tests clean up after themselves (e.g., resetting database state). Run the entire test suite to ensure that the new features have not introduced any regressions in existing functionality.",
        "testStrategy": "Run `pytest` and ensure all tests pass. Check the code coverage report to identify any untested code paths in the new service functions and router logic.",
        "priority": "medium",
        "dependencies": [
          16,
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Refactor Database Fixture for Test Isolation",
            "description": "The current database fixture in `tests/conftest.py` is session-scoped, which causes data to persist between tests. This must be changed to ensure each test runs in isolation with a clean database state.",
            "dependencies": [],
            "details": "Modify the `db` fixture in `tests/conftest.py`. Change its scope from `@pytest.fixture(scope=\"session\")` to `@pytest.fixture(scope=\"function\")`. Instead of dropping and creating all tables for each function, a more efficient approach is to start a transaction at the beginning of the test and roll it back at the end. This will ensure any data created during a test is discarded before the next test runs.",
            "status": "pending",
            "testStrategy": "After refactoring, run the test suite. If tests that previously passed due to shared state now fail, it indicates the change is working correctly. Fix any such failing tests."
          },
          {
            "id": 2,
            "title": "Review and Enhance Tests for `PUT /bind` Endpoint",
            "description": "With the new isolated database fixture, review and improve the existing integration tests for the `/bind` endpoint in `tests/routers/test_users.py` to ensure they are robust and cover all scenarios.",
            "dependencies": [
              "20.1"
            ],
            "details": "In `tests/routers/test_users.py`, adapt the existing tests (`test_bind_user_success`, `test_bind_user_username_conflict`, `test_bind_user_invalid_invite_code`) to the new function-scoped database fixture. Add a new test case to verify the behavior when a user who is already bound tries to bind again. Ensure assertions correctly check both the status code and the response body content.",
            "status": "pending",
            "testStrategy": "Run the specific tests for the `/bind` endpoint to confirm they pass in isolation and correctly validate the endpoint's logic."
          },
          {
            "id": 3,
            "title": "Review and Enhance Tests for `GET /initState` Endpoint",
            "description": "Review and improve the existing integration tests for the `/initState` endpoint in `tests/routers/test_users.py`, ensuring comprehensive coverage of different user states.",
            "dependencies": [
              "20.1"
            ],
            "details": "In `tests/routers/test_users.py`, adapt the existing tests for `/initState` (`test_get_initial_state_success`, `test_get_initial_state_null_defaults`, `test_get_initial_state_unauthorized`) to the new isolated test environment. Add a test case for a newly created user who has not yet been bound to a profile, verifying that the `initState` response contains the expected default/null values.",
            "status": "pending",
            "testStrategy": "Run the specific tests for the `/initState` endpoint. Verify that the responses are correct for users in different states (e.g., fully initialized, partially initialized, unbound)."
          },
          {
            "id": 4,
            "title": "Organize User-Related Tests with Classes and Markers",
            "description": "Consolidate and organize the tests within `tests/routers/test_users.py` and `tests/services/test_user_service.py` for better readability and maintenance.",
            "dependencies": [
              "20.2",
              "20.3"
            ],
            "details": "In `tests/routers/test_users.py`, group related tests into classes (e.g., `class TestBindEndpoint:`, `class TestInitStateEndpoint:`). This will make the test file more structured. Similarly, review `tests/services/test_user_service.py` for clarity. Consider adding `pytest.mark` decorators (e.g., `@pytest.mark.integration`, `@pytest.mark.unit`) to distinguish between test types, which can be useful for running specific subsets of tests.",
            "status": "pending",
            "testStrategy": "Run `pytest` after restructuring to ensure all tests are still discovered and executed correctly. Use `pytest -m integration` to verify the markers are working."
          },
          {
            "id": 5,
            "title": "Run Full Test Suite and Analyze Code Coverage",
            "description": "Execute the entire test suite to check for any regressions and then generate a code coverage report to identify any untested code paths in the new user session and initialization features.",
            "dependencies": [
              "20.4"
            ],
            "details": "Run the full test suite using the `pytest` command from the project root. After confirming all tests pass, run `pytest --cov=moneynote` to generate a coverage report. Analyze the output, paying close attention to the coverage percentages for `moneynote/routers/users.py` and `moneynote/services/user_service.py`. If significant gaps are found, add new unit or integration tests to cover the missing logic.",
            "status": "pending",
            "testStrategy": "The primary goal is to have all tests passing and to achieve a high code coverage percentage for the modified and new modules. The final report should show no obvious gaps in testing the core logic of the `/bind` and `/initState` features."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-08T08:23:31.360Z",
      "updated": "2025-10-10T05:58:00.989Z",
      "description": "Tasks for master context"
    }
  }
}