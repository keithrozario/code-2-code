{
  "master": {
    "tasks": [
      {
        "id": 11,
        "title": "Update Data Models and Create Database Migration",
        "description": "Update the `User` model to support binding and create a new `InviteCode` model. This involves modifying SQLAlchemy models and generating a database migration with Alembic.",
        "details": "In `moneynote/models/user.py`, ensure the `User` model's `username` and `password_hash` columns are nullable to accommodate guest accounts. Create a new file `moneynote/models/invite_code.py` with an `InviteCode` model mapping to `t_invite_code`. This table should at least contain `code` (string, unique) and `is_used` (boolean) columns. After defining the models, run `alembic revision --autogenerate` to create the migration script.",
        "testStrategy": "Review the generated Alembic migration script to ensure it correctly alters `t_user_user` and creates `t_invite_code`. Apply the migration to a test database to confirm it runs without errors.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Make User Model Fields Nullable",
            "description": "Modify the User model in `moneynote/models/user.py` to allow `username` and `password_hash` to be nullable. This supports guest user accounts that are not yet bound to credentials.",
            "dependencies": [],
            "details": "In the file `moneynote/models/user.py`, locate the `User` class. Change the `nullable=False` argument to `nullable=True` for both the `username` and `password_hash` columns.",
            "status": "pending",
            "testStrategy": "Code review to confirm the `nullable` property is set to `True` for the specified columns."
          },
          {
            "id": 2,
            "title": "Create InviteCode Model File",
            "description": "Create a new file `moneynote/models/invite_code.py` and define the `InviteCode` SQLAlchemy model within it.",
            "dependencies": [],
            "details": "Create the new file. Inside, import `Column`, `Integer`, `String`, `Boolean` from `sqlalchemy` and `Base` from `.base`. Define a new class `InviteCode(Base)` with `__tablename__ = 't_invite_code'`. Add the following columns: `id` (Integer, primary_key=True), `code` (String(50), unique=True, nullable=False), and `is_used` (Boolean, nullable=False, default=False).",
            "status": "pending",
            "testStrategy": "Code review to ensure the new model is defined correctly according to SQLAlchemy conventions and project requirements."
          },
          {
            "id": 3,
            "title": "Register New InviteCode Model for Alembic Discovery",
            "description": "Update `moneynote/models/__init__.py` to import the new `InviteCode` model, making it discoverable by Alembic for autogeneration.",
            "dependencies": [
              "11.2"
            ],
            "details": "In `moneynote/models/__init__.py`, add the line `from .invite_code import InviteCode`. Then, add `'InviteCode'` to the `__all__` list to follow the existing pattern in the file.",
            "status": "pending",
            "testStrategy": "Verify that the import statement and the `__all__` list are correctly updated in `moneynote/models/__init__.py`."
          },
          {
            "id": 4,
            "title": "Generate Alembic Migration Script",
            "description": "Run the Alembic command to automatically generate a new database migration script based on the model changes.",
            "dependencies": [
              "11.1",
              "11.3"
            ],
            "details": "From the project's root directory, execute the command: `alembic revision --autogenerate -m \"Add InviteCode model and make User fields nullable\"`. This will create a new revision file in the `alembic/versions` directory.",
            "status": "pending",
            "testStrategy": "Confirm that a new migration file is created in `alembic/versions/` after running the command."
          },
          {
            "id": 5,
            "title": "Review and Finalize Generated Migration Script",
            "description": "Inspect the newly generated migration script to ensure it accurately reflects the intended database schema changes and that both upgrade and downgrade paths are correct.",
            "dependencies": [
              "11.4"
            ],
            "details": "Open the new file in `alembic/versions/`. In the `upgrade()` function, verify the presence of `op.create_table('t_invite_code', ...)` with the correct columns and constraints. Also, confirm there are two `op.alter_column('t_user_user', ...)` calls to set `nullable=True` for `username` and `password_hash`. Check that the `downgrade()` function correctly reverses these operations.",
            "status": "pending",
            "testStrategy": "Apply the migration to a local/test database (`alembic upgrade head`) and inspect the database schema to confirm the `t_invite_code` table is created and the `t_user_user` table is altered as expected."
          }
        ]
      },
      {
        "id": 12,
        "title": "Define Pydantic Schemas for Session and Binding",
        "description": "Create the Pydantic schemas required for the `/initState` response and the `/bind` request body.",
        "details": "In a relevant schema file like `moneynote/schemas/user.py`, define `UserSessionVo`, `BookSessionVo`, and `GroupSessionVo` to structure the `initState` response, including fields like `id` and `name`. Create a `UserBind` schema for the `PUT /bind` request body, containing `username: str`, `password: str`, and `inviteCode: str`.",
        "testStrategy": "No direct testing is needed for schemas, but they will be validated by unit tests for the services and integration tests for the endpoints that use them.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define UserBind Schema for the /bind Endpoint",
            "description": "Create the Pydantic schema for the request body of the `PUT /bind` endpoint. This schema will be used to validate the data sent when a user binds their account.",
            "dependencies": [],
            "details": "In `moneynote/schemas/user.py`, define a new Pydantic class `UserBind` that inherits from `BaseModel`. This class should include the following fields: `username: str`, `password: str`, and `inviteCode: str`.",
            "status": "pending",
            "testStrategy": "This schema will be implicitly tested by the integration tests for the `/bind` endpoint (Task 19), which will validate request body handling."
          },
          {
            "id": 2,
            "title": "Define UserSessionVo Schema for the /initState Response",
            "description": "Create the Pydantic schema for the user portion of the `GET /initState` response. This will represent the essential user session information.",
            "dependencies": [],
            "details": "In `moneynote/schemas/user.py`, define a new Pydantic class `UserSessionVo` that inherits from `BaseModel`. It should contain `id: int` and `name: str` fields. Add a `Config` inner class with `orm_mode = True` to allow mapping from ORM models.",
            "status": "pending",
            "testStrategy": "This schema will be validated by unit and integration tests for the `get_initial_state` service and `/initState` endpoint (Tasks 15 and 19)."
          },
          {
            "id": 3,
            "title": "Define BookSessionVo Schema for the /initState Response",
            "description": "Create the Pydantic schema for the user's default book portion of the `GET /initState` response.",
            "dependencies": [],
            "details": "In `moneynote/schemas/user.py`, define a new Pydantic class `BookSessionVo` that inherits from `BaseModel`. It should contain `id: int` and `name: str` fields. Add a `Config` inner class with `orm_mode = True`.",
            "status": "pending",
            "testStrategy": "This schema will be validated by unit and integration tests for the `get_initial_state` service and `/initState` endpoint (Tasks 15 and 19)."
          },
          {
            "id": 4,
            "title": "Define GroupSessionVo Schema for the /initState Response",
            "description": "Create the Pydantic schema for the user's group portion of the `GET /initState` response.",
            "dependencies": [],
            "details": "In `moneynote/schemas/user.py`, define a new Pydantic class `GroupSessionVo` that inherits from `BaseModel`. It should contain `id: int` and `name: str` fields. Add a `Config` inner class with `orm_mode = True`.",
            "status": "pending",
            "testStrategy": "This schema will be validated by unit and integration tests for the `get_initial_state` service and `/initState` endpoint (Tasks 15 and 19)."
          },
          {
            "id": 5,
            "title": "Define Composite InitStateResponse Schema",
            "description": "Create the main Pydantic schema that composes the session VOs into the final structure for the `GET /initState` response body.",
            "dependencies": [
              "12.2",
              "12.3",
              "12.4"
            ],
            "details": "In `moneynote/schemas/user.py`, define a new Pydantic class `InitStateResponse`. This schema will assemble the previously defined VOs. It should contain the fields: `user: UserSessionVo`, `book: Optional[BookSessionVo] = None`, and `group: Optional[GroupSessionVo] = None`. Import `Optional` from the `typing` module.",
            "status": "pending",
            "testStrategy": "This composite schema is the primary response model for the `/initState` endpoint and will be thoroughly validated by its integration tests (Task 19)."
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement CRUD Functions for User and Invite Code",
        "description": "Create the necessary Data Access Layer functions to interact with the user and invite code tables for the new features.",
        "details": "In `moneynote/crud/crud_user.py`, add a `get_by_username` function to check for username uniqueness. In `moneynote/crud/crud_user.py` ensure the `update` function can modify `username` and `password_hash`. Create a new file `moneynote/crud/crud_invite_code.py` with functions to fetch an invite code (`get_by_code`) and to mark it as used (`update`).",
        "testStrategy": "Write unit tests for each new CRUD function, mocking the database session and asserting that the correct SQLAlchemy methods are called with the right parameters.",
        "priority": "high",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement `get_by_username` in `CRUDUser`",
            "description": "In `moneynote/crud/crud_user.py`, add a new method `get_by_username` to the `CRUDUser` class. This method should accept a database session and a username string, and return the corresponding `User` object or `None` if not found.",
            "dependencies": [],
            "details": "Follow the existing pattern of the `get_by_email` method. The new method signature should be `def get_by_username(self, db: Session, *, username: str) -> Optional[User]:`. The implementation should query the `User` model, filtering by the `username` column.",
            "status": "pending",
            "testStrategy": "Add a unit test for `get_by_username`, mocking the database session and asserting that `db.query(User).filter(...).first()` is called with the correct parameters."
          },
          {
            "id": 2,
            "title": "Update `UserUpdate` Schema and `CRUDUser.update` Method",
            "description": "Modify the `UserUpdate` schema in `moneynote/schemas/user.py` to allow updating the username and hashed password. Then, adjust the `CRUDUser.update` method in `moneynote/crud/crud_user.py` to correctly handle these fields.",
            "dependencies": [],
            "details": "In `moneynote/schemas/user.py`, add `username: Optional[str] = None` and `hashed_password: Optional[str] = None` to the `UserUpdate` Pydantic model. In `moneynote/crud/crud_user.py`, modify the `CRUDUser.update` method to remove the special handling for a raw `password`. The updated data, including `username` and `hashed_password`, will be passed directly to the `super().update()` call.",
            "status": "pending",
            "testStrategy": "Update the unit tests for `CRUDUser.update` to verify that `username` and `hashed_password` can be updated correctly. Test that the old logic for hashing a raw `password` is removed or no longer triggered."
          },
          {
            "id": 3,
            "title": "Create `moneynote/crud/crud_invite_code.py` and Define `CRUDInviteCode`",
            "description": "Create a new file `moneynote/crud/crud_invite_code.py`. In this file, define the `CRUDInviteCode` class that inherits from `CRUDBase` and instantiate it for use in other modules.",
            "dependencies": [],
            "details": "The new file should import `CRUDBase` from `moneynote.crud.base`, the `InviteCode` model from `moneynote.models.invite_code`, and the `InviteCodeCreate` and `InviteCodeUpdate` schemas from `moneynote.schemas.invite_code`. Define the class as `class CRUDInviteCode(CRUDBase[InviteCode, InviteCodeCreate, InviteCodeUpdate]): pass`. Finally, create an instance: `invite_code = CRUDInviteCode(InviteCode)`.",
            "status": "pending",
            "testStrategy": "This is primarily a structural task. Verification can be done by ensuring the application can import the `invite_code` object from the new module without errors."
          },
          {
            "id": 4,
            "title": "Implement `get_by_code` in `CRUDInviteCode`",
            "description": "In the newly created `moneynote/crud/crud_invite_code.py`, add a `get_by_code` method to the `CRUDInviteCode` class to fetch an invite code record from the database.",
            "dependencies": [
              "13.3"
            ],
            "details": "The method should accept a database session and a `code` string. It should query the `InviteCode` model, filtering on the `code` column, and return the first result or `None`. The method signature should be `def get_by_code(self, db: Session, *, code: str) -> Optional[InviteCode]:`.",
            "status": "pending",
            "testStrategy": "Write a unit test for `get_by_code`, mocking the database session and asserting that the correct query is executed to find the invite code."
          },
          {
            "id": 5,
            "title": "Ensure `CRUDInviteCode` Provides an `update` Method",
            "description": "The `CRUDInviteCode` class, by inheriting from `CRUDBase`, already has a generic `update` method. This task is to confirm that the class is set up correctly to use this inherited method for marking an invite code as used.",
            "dependencies": [
              "13.3"
            ],
            "details": "No new code needs to be written for the `update` method itself within `crud_invite_code.py`. The implementation is inherited from `CRUDBase`. The `bind_user` service will call this method with a dictionary of fields to update (e.g., `is_used=True`). This subtask is complete once the `CRUDInviteCode` class is correctly defined as per subtask 13.3, as this provides the required functionality.",
            "status": "pending",
            "testStrategy": "Write a unit test that calls `invite_code.update`. Mock the database session and a `db_obj`, and verify that `db.add()` and `db.commit()` are called, confirming the inherited `update` logic is functioning as expected for the `InviteCode` model."
          }
        ]
      },
      {
        "id": 14,
        "title": "Add Password Hashing Utility and Dependency",
        "description": "Integrate a password hashing library and create utility functions for hashing and verification.",
        "details": "Add `passlib` with `bcrypt` support to the project's dependencies in `pyproject.toml`. In `moneynote/security.py`, create a `get_password_hash(password: str) -> str` function and a `verify_password(plain_password: str, hashed_password: str) -> bool` function using `passlib.context.CryptContext`.",
        "testStrategy": "Write unit tests for the `get_password_hash` and `verify_password` functions to ensure they correctly hash passwords and that verification works for both correct and incorrect passwords.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add passlib with bcrypt to pyproject.toml",
            "description": "Modify the project's dependency file, `pyproject.toml`, to include the `passlib` library with support for the `bcrypt` hashing algorithm.",
            "dependencies": [],
            "details": "In `pyproject.toml`, under the `[tool.poetry.dependencies]` section, add the following line: `passlib = {extras = [\"bcrypt\"], version = \"^1.7.4\"}`. After editing the file, run `poetry lock && poetry install` to update the project's environment.",
            "status": "pending",
            "testStrategy": "Verify the dependency is installed correctly by running `poetry show passlib` in the terminal."
          },
          {
            "id": 2,
            "title": "Create and configure CryptContext in security.py",
            "description": "In `moneynote/security.py`, import `CryptContext` from `passlib.context` and create a configured instance to be used for hashing and verification.",
            "dependencies": [
              "14.1"
            ],
            "details": "Add `from passlib.context import CryptContext` to the imports in `moneynote/security.py`. Then, create a module-level variable: `pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")`. This context will be used by the hashing and verification functions.",
            "status": "pending",
            "testStrategy": "No direct testing for this subtask. Its correctness will be verified by the tests for the functions that use it."
          },
          {
            "id": 3,
            "title": "Implement get_password_hash function",
            "description": "Create the `get_password_hash` function in `moneynote/security.py` to hash a plain-text password.",
            "dependencies": [
              "14.2"
            ],
            "details": "Define the function `get_password_hash(password: str) -> str`. Inside the function, use the `pwd_context` instance to hash the password: `return pwd_context.hash(password)`.",
            "status": "pending",
            "testStrategy": "Unit tests will be written in a subsequent subtask to verify that the function returns a string and that the hash is different from the input password."
          },
          {
            "id": 4,
            "title": "Implement verify_password function",
            "description": "Create the `verify_password` function in `moneynote/security.py` to check a plain-text password against a hashed password.",
            "dependencies": [
              "14.2"
            ],
            "details": "Define the function `verify_password(plain_password: str, hashed_password: str) -> bool`. Inside the function, use the `pwd_context` instance to verify the password: `return pwd_context.verify(plain_password, hashed_password)`.",
            "status": "pending",
            "testStrategy": "Unit tests will be written in a subsequent subtask to verify that the function returns `True` for a correct password and `False` for an incorrect one."
          },
          {
            "id": 5,
            "title": "Write unit tests for password utility functions",
            "description": "Create a new test file `tests/test_security.py` and add unit tests for the `get_password_hash` and `verify_password` functions to ensure they work correctly.",
            "dependencies": [
              "14.3",
              "14.4"
            ],
            "details": "In `tests/test_security.py`, import the two new functions. Write a test case for `get_password_hash` to ensure it returns a non-empty string. Write test cases for `verify_password` that check both a correct password (should return `True`) and an incorrect password (should return `False`).",
            "status": "pending",
            "testStrategy": "Run `pytest tests/test_security.py` and ensure all new tests pass."
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement `get_initial_state` Service Logic",
        "description": "Create the business logic for the `initState` feature, which fetches the core session data for a user.",
        "details": "In `moneynote/services/user_service.py`, create a new function `get_initial_state(db: Session, user_id: int)`. This function will use `crud_user` to fetch the user, then use the `user.default_book_id` and `user.group_id` to fetch the corresponding book and group records via their respective CRUD modules. It should handle cases where the book or group might be null and assemble the data into a dictionary or a dedicated data object.",
        "testStrategy": "Write unit tests for the `get_initial_state` service function. Mock the CRUD functions to simulate different scenarios, such as a user with a default book, a user without one, and a user not found.",
        "priority": "medium",
        "dependencies": [
          13
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define `InitialState` Response Schema",
            "description": "Create a new Pydantic schema `InitialState` to define the structure of the data returned by the `get_initial_state` service. This schema will encapsulate the user, their default book, and their group.",
            "dependencies": [],
            "details": "In `moneynote/schemas/user.py`, add a new class `InitialState(BaseModel)`. It should contain three fields: `user: User`, `book: Optional[Book]`, and `group: Optional[Group]`. You will need to import `Optional` from `typing`, `BaseModel` from `pydantic`, `Book` from `.book`, and `Group` from `.group`.",
            "status": "pending",
            "testStrategy": "No specific test is needed for this schema, as it will be validated by the tests for the service function that uses it."
          },
          {
            "id": 2,
            "title": "Create `get_initial_state` Function and Fetch User",
            "description": "In `moneynote/services/user_service.py`, create the `get_initial_state` function. This function will fetch the specified user from the database and handle the case where the user does not exist.",
            "dependencies": [
              "15.1"
            ],
            "details": "Define the function `get_initial_state(db: Session, user_id: int) -> InitialState:`. Import necessary modules: `Session` from `sqlalchemy.orm`, `HTTPException` and `status` from `fastapi`, `crud_user` from `moneynote.crud`, and the new `InitialState` schema from `moneynote.schemas`. Use `crud_user.get(db, id=user_id)` to retrieve the user. If the user is not found, raise an `HTTPException` with `status_code=status.HTTP_404_NOT_FOUND` and detail 'User not found'.",
            "status": "pending",
            "testStrategy": "Write a unit test that mocks `crud_user.get` to return `None` and assert that an `HTTPException` with status 404 is raised."
          },
          {
            "id": 3,
            "title": "Integrate Default Book Fetching Logic",
            "description": "Extend the `get_initial_state` function to fetch the user's default book using the `default_book_id` from the user object.",
            "dependencies": [
              "15.2"
            ],
            "details": "In `moneynote/services/user_service.py`, import `crud_book`. Inside `get_initial_state`, after fetching the user, initialize a variable `book = None`. Check if `user.default_book_id` has a value. If it does, use `crud_book.get(db, id=user.default_book_id)` to fetch the book and assign it to the `book` variable. The function should gracefully handle if the book is not found (i.e., `book` remains `None`).",
            "status": "pending",
            "testStrategy": "Write a unit test that mocks `crud_user.get` to return a user with a `default_book_id`. Mock `crud_book.get` to return a book object and assert it's in the final result. Also, test the case where `default_book_id` is present but `crud_book.get` returns `None`."
          },
          {
            "id": 4,
            "title": "Integrate Group Fetching Logic",
            "description": "Extend the `get_initial_state` function to fetch the user's group using the `group_id` from the user object.",
            "dependencies": [
              "15.2"
            ],
            "details": "In `moneynote/services/user_service.py`, import `crud_group`. Inside `get_initial_state`, initialize a variable `group = None`. Check if `user.group_id` has a value. If it does, use `crud_group.get(db, id=user.group_id)` to fetch the group and assign it to the `group` variable. The function should gracefully handle if the group is not found (i.e., `group` remains `None`).",
            "status": "pending",
            "testStrategy": "Write a unit test that mocks `crud_user.get` to return a user with a `group_id`. Mock `crud_group.get` to return a group object and assert it's in the final result. Also, test the case where `group_id` is present but `crud_group.get` returns `None`."
          },
          {
            "id": 5,
            "title": "Assemble and Return Final `InitialState` Object",
            "description": "Complete the `get_initial_state` function by assembling the fetched user, book, and group data into the `InitialState` schema object and returning it.",
            "dependencies": [
              "15.3",
              "15.4"
            ],
            "details": "At the end of the `get_initial_state` function, create and return an instance of the `InitialState` schema: `return InitialState(user=user, book=book, group=group)`. This combines the results from the previous steps into the final, structured response object.",
            "status": "pending",
            "testStrategy": "Write a comprehensive unit test that simulates a user with both a book and a group, and another test for a user with neither. Assert that the returned `InitialState` object contains the correct data (or `None`) for each field."
          }
        ]
      },
      {
        "id": 16,
        "title": "Implement `bind_user` Service Logic",
        "description": "Create the business logic for binding a username and password to an existing user account, including all validations.",
        "details": "In `moneynote/services/user_service.py`, create a function `bind_user(db: Session, user_id: int, bind_data: UserBind)`. This function will: 1. Use `crud_invite_code` to validate the invite code. 2. Use `crud_user.get_by_username` to check for username uniqueness. 3. Use `security.get_password_hash` to hash the password. 4. Use `crud_user.update` to save the new username and hashed password. 5. Raise specific `HTTPException`s with error codes for each validation failure (e.g., `bind.username.exists`, `bind.invite.code.invalid`).",
        "testStrategy": "Write unit tests for the `bind_user` service function, covering all business logic paths: successful binding, username already taken, invalid invite code, and used invite code.",
        "priority": "medium",
        "dependencies": [
          13,
          14
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define `bind_user` Function and Add Imports",
            "description": "In `moneynote/services/user_service.py`, create the function signature for `bind_user(db: Session, user_id: int, bind_data: UserBind)`. Add all necessary imports: `Session` from `sqlalchemy.orm`, `HTTPException` from `fastapi`, `crud_user` and `crud_invite_code` from `moneynote.crud`, `security` from `moneynote.core`, and the `UserBind` schema from `moneynote.schemas`.",
            "dependencies": [],
            "details": "Create the basic structure of the `bind_user` function. Ensure all required modules and schemas are imported at the top of the file to prepare for implementing the business logic. The function should initially be a stub that returns `None` or has a `pass` statement.",
            "status": "pending",
            "testStrategy": "No specific test needed for this setup task, but subsequent tests will fail until this is complete."
          },
          {
            "id": 2,
            "title": "Implement Invite Code Validation",
            "description": "Inside the `bind_user` function, implement the logic to validate the invite code provided in `bind_data`. Use `crud_invite_code.get_by_code` to fetch the code. If the code is not found or if its `is_used` attribute is `True`, raise an `HTTPException` with `status_code=400` and a detail of `bind.invite.code.invalid`.",
            "dependencies": [
              "16.1"
            ],
            "details": "This is the first validation step. Call `crud_invite_code.get_by_code(db, code=bind_data.invite_code)`. Check the result. If it's `None` or `result.is_used`, raise the specified exception. Keep the valid invite code object in a variable for later use.",
            "status": "pending",
            "testStrategy": "Write a unit test case that calls `bind_user` with a non-existent invite code and asserts that the correct `HTTPException` is raised. Write another test case for an invite code that is already marked as used."
          },
          {
            "id": 3,
            "title": "Implement Username Uniqueness Check",
            "description": "Add logic to check if the username from `bind_data` is already taken. Use `crud_user.get_by_username` to query for an existing user with that username. If a user is found, raise an `HTTPException` with `status_code=400` and a detail of `bind.username.exists`.",
            "dependencies": [
              "16.1"
            ],
            "details": "This is the second validation step. Call `crud_user.get_by_username(db, username=bind_data.username)`. If the result is not `None`, it means the username is taken, and the specific exception should be raised.",
            "status": "pending",
            "testStrategy": "Write a unit test case where `crud_user.get_by_username` is mocked to return an existing user. Assert that calling `bind_user` raises the `HTTPException` for an existing username."
          },
          {
            "id": 4,
            "title": "Hash Password and Update User Record",
            "description": "Implement the logic to update the user's credentials. First, fetch the user object using `crud_user.get(db, id=user_id)`. Then, use `security.get_password_hash` to hash the password from `bind_data`. Finally, use `crud_user.update` to save the new `username` and `hashed_password` to the user's record.",
            "dependencies": [
              "16.1",
              "16.2",
              "16.3"
            ],
            "details": "Create a dictionary containing the update data: `{'username': bind_data.username, 'hashed_password': security.get_password_hash(bind_data.password)}`. Pass this dictionary to the `obj_in` parameter of the `crud_user.update` function.",
            "status": "pending",
            "testStrategy": "In a successful path unit test, assert that `security.get_password_hash` is called once with the correct password. Also, assert that `crud_user.update` is called with the correct user object and an update dictionary containing the new username and the hashed password."
          },
          {
            "id": 5,
            "title": "Mark Invite Code as Used and Return User",
            "description": "After the user record has been successfully updated, mark the invite code as used. Use `crud_invite_code.update` on the invite code object retrieved in the validation step, setting its `is_used` flag to `True` and associating the `user_id`. Finally, return the updated user object from the `bind_user` function.",
            "dependencies": [
              "16.4"
            ],
            "details": "This step ensures an invite code cannot be reused. Call `crud_invite_code.update` with the invite code object and an update dictionary like `{'is_used': True, 'used_by_user_id': user_id}`. The function should return the user object that was returned by `crud_user.update`.",
            "status": "pending",
            "testStrategy": "In the successful path unit test, assert that `crud_invite_code.update` is called with the correct invite code object and the correct update data. Also, assert that the final return value of `bind_user` is the updated user object."
          }
        ]
      },
      {
        "id": 17,
        "title": "Create `GET /initState` API Endpoint",
        "description": "Expose the `get_initial_state` service logic through a new API endpoint in the user router.",
        "details": "In `moneynote/routers/users.py`, create a new FastAPI endpoint for `GET /initState`. This endpoint must be protected by the existing `get_current_user` dependency. It will call the `user_service.get_initial_state` function and return the result, using the schemas defined in task 12 for the response model.",
        "testStrategy": "Integration tests will be written in a later task. Manual testing can be done via Swagger UI to confirm the endpoint works as expected.",
        "priority": "medium",
        "dependencies": [
          12,
          15
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Import `InitialState` Schema and `user_service` in `users.py`",
            "description": "Update the import statements in `moneynote/routers/users.py` to include the `InitialState` response schema from task 12 and the `user_service` module from task 15.",
            "dependencies": [],
            "details": "In `moneynote/routers/users.py`, add `from ..schemas.user_schemas import InitialState` and `from ..services import user_service`. Verify that other necessary imports like `APIRouter`, `Depends`, `Session`, `get_db`, `get_current_user`, and `models` are already present for use in subsequent steps.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create the `GET /initState` Route Decorator",
            "description": "In `moneynote/routers/users.py`, add the FastAPI decorator for the new endpoint. This will define the path, HTTP method, and the response model.",
            "dependencies": [
              "17.1"
            ],
            "details": "Below the existing router definition (`router = APIRouter(...)`), add a new decorator: `@router.get(\"/initState\", response_model=InitialState, summary=\"Get Initial User State\")`. This sets the path and ensures the JSON response conforms to the `InitialState` schema.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Define the Endpoint Function with Dependencies",
            "description": "Create the Python function signature for the `/initState` endpoint, injecting the required database session and the authenticated user object.",
            "dependencies": [
              "17.2"
            ],
            "details": "Directly below the decorator from the previous subtask, define the function signature as: `def get_user_initial_state(db: Session = Depends(get_db), current_user: models.User = Depends(get_current_user)) -> InitialState:`. This correctly injects the dependencies needed for the endpoint's logic.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Call the `user_service.get_initial_state` Function",
            "description": "Inside the new endpoint function, implement the call to the business logic layer to fetch the initial state data for the authenticated user.",
            "dependencies": [
              "17.3"
            ],
            "details": "Inside the `get_user_initial_state` function, add the line `initial_state = user_service.get_initial_state(db=db, user_id=current_user.id)`. This retrieves the user ID from the `current_user` object (provided by the `get_current_user` dependency) and passes it to the service function.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Return the Fetched Initial State Data",
            "description": "Complete the endpoint implementation by returning the data retrieved from the service layer, allowing FastAPI to serialize it into a JSON response.",
            "dependencies": [
              "17.4"
            ],
            "details": "Add the final line `return initial_state` to the `get_user_initial_state` function. This will pass the result from the service call back to FastAPI, which will handle the response generation based on the `response_model`.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 18,
        "title": "Create `PUT /bind` API Endpoint",
        "description": "Expose the `bind_user` service logic through a new API endpoint for updating a user's credentials.",
        "details": "In `moneynote/routers/users.py`, create a new FastAPI endpoint for `PUT /bind`. It must be protected by the `get_current_user` dependency. It will accept a `UserBind` schema in the request body and pass the data to the `user_service.bind_user` function. It should correctly propagate HTTP exceptions from the service layer.",
        "testStrategy": "Integration tests will be written in a later task. Manual testing can be done via Swagger UI to confirm all success and error responses.",
        "priority": "medium",
        "dependencies": [
          12,
          16
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Import necessary schemas and services in users.py",
            "description": "In `moneynote/routers/users.py`, update the import statements to include the `UserBind` schema required for the request body and the `User` schema for the response model.",
            "dependencies": [],
            "details": "Locate the import section at the top of `moneynote/routers/users.py`. Modify the line `from .. import services, schemas` or add new lines to specifically import `schemas.UserBind` and ensure `schemas.User` is available. The `user_service` is already imported via `services`.",
            "status": "pending",
            "testStrategy": "Verify the file is syntactically correct after adding the imports."
          },
          {
            "id": 2,
            "title": "Define the `PUT /bind` endpoint signature",
            "description": "In `moneynote/routers/users.py`, create the function signature for the new endpoint using the `@router.put` decorator. Specify the path `/bind` and set the `response_model` to `schemas.User`.",
            "dependencies": [
              "18.1"
            ],
            "details": "Add the following code block to `moneynote/routers/users.py`:\n\n```python\n@router.put(\"/bind\", response_model=schemas.User)\nasync def bind_user_credentials():\n    pass\n```\n\nThis creates the basic structure of the endpoint. The function name `bind_user_credentials` is a suggestion; a suitable name should be chosen.",
            "status": "pending",
            "testStrategy": "Run the FastAPI development server and check the `/docs` page to see if the new `PUT /users/bind` endpoint appears correctly."
          },
          {
            "id": 3,
            "title": "Inject request body and database session dependencies",
            "description": "Update the endpoint function signature to accept the request body, typed as `schemas.UserBind`, and to depend on the database session `db: Session`.",
            "dependencies": [
              "18.2"
            ],
            "details": "Modify the function signature created in the previous subtask. Add a parameter for the request body `bind_data: schemas.UserBind` and another for the database session `db: Session = Depends(get_db)`. Ensure `get_db` is imported from `..database`.",
            "status": "pending",
            "testStrategy": "Check the `/docs` page again. The endpoint should now show a request body field expecting the `UserBind` schema and a parameter for the database dependency."
          },
          {
            "id": 4,
            "title": "Add `get_current_user` authentication dependency",
            "description": "Protect the endpoint by adding the `get_current_user` dependency to the function signature. This will ensure only authenticated users can access this endpoint and will provide the user's data to the function.",
            "dependencies": [
              "18.3"
            ],
            "details": "Add the `current_user: models.User = Depends(get_current_user)` parameter to the endpoint's function signature. The `get_current_user` dependency is already imported from `..auth`. The type hint `models.User` should be used for clarity, and `models` should be imported if not already.",
            "status": "pending",
            "testStrategy": "Use the Swagger UI (`/docs`) to try and execute the endpoint without an authentication token. It should fail with a 401 Unauthorized error."
          },
          {
            "id": 5,
            "title": "Implement service layer call and return result",
            "description": "In the body of the endpoint function, call the `user_service.bind_user` function, passing the database session, the current user object, and the request body data. Return the result of this service call.",
            "dependencies": [
              "18.4"
            ],
            "details": "The implementation should be a single line: `return services.user_service.bind_user(db=db, user=current_user, user_bind=bind_data)`. FastAPI will automatically handle propagating any `HTTPException` raised by the service and will serialize the returned `models.User` object into a `schemas.User` response.",
            "status": "pending",
            "testStrategy": "Manually test the endpoint via Swagger UI. Test a successful update, and test error cases like providing a username that is already taken to ensure the 400 error from the service layer is correctly returned."
          }
        ]
      },
      {
        "id": 19,
        "title": "Write Integration Tests for Phase 2 Endpoints",
        "description": "Create a suite of integration tests for the new `/initState` and `/bind` endpoints to ensure they are working correctly from an API consumer's perspective.",
        "details": "In the `tests/` directory, create a new test file. For `GET /initState`, write tests for success (200 OK), unauthorized (401), and user not found (404). For `PUT /bind`, write tests for success (200 OK), unauthorized (401), and bad requests (400) for cases like duplicate username and invalid invite code. Use FastAPI's `TestClient`.",
        "testStrategy": "Run the Pytest suite and ensure all new tests pass. Check test coverage to confirm the new endpoints and service logic are adequately tested.",
        "priority": "low",
        "dependencies": [
          17,
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Test File and Implement Unauthorized (401) Tests",
            "description": "Create a new test file and add tests for the `/initState` and `/bind` endpoints to ensure they return a 401 Unauthorized error when no authentication token is provided.",
            "dependencies": [],
            "details": "In the `tests/api/v1/` directory, create a new file named `test_phase2_endpoints.py`. Add a test function `test_get_init_state_unauthorized` that makes a GET request to `/api/v1/initState` without an `Authorization` header. Add another test `test_bind_user_unauthorized` that makes a PUT request to `/api/v1/bind` with a sample body but no `Authorization` header. Both tests must assert that the HTTP status code is 401.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Success (200) and Not Found (404) Tests for GET /initState",
            "description": "Write tests to verify the success and user-not-found scenarios for the `/initState` endpoint.",
            "dependencies": [
              "19.1"
            ],
            "details": "In `tests/api/v1/test_phase2_endpoints.py`, create `test_get_init_state_success`. Use the `normal_user_token_headers` fixture to make an authenticated GET request to `/api/v1/initState`. Assert a 200 OK status and validate that the response body contains the expected user, book, and group data. Then, create `test_get_init_state_user_not_found`. This test should create a user, generate a token, delete the user from the DB, and then make a request with the stale token, asserting a 404 Not Found status code, which should be raised by the `get_current_active_user` dependency.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Success (200) Test for PUT /bind",
            "description": "Write a test for the successful binding of a username and password to a user account using a valid invite code.",
            "dependencies": [
              "19.1"
            ],
            "details": "In `tests/api/v1/test_phase2_endpoints.py`, create `test_bind_user_success`. This test requires setting up a user (e.g., via `create_random_user`) and a valid, unused invite code in the database. Use the user's token from the `normal_user_token_headers` fixture. Call `PUT /api/v1/bind` with a payload containing a unique username, a password, and the valid invite code. Assert a 200 OK status. Additionally, verify that the user's `username` and `password_hash` fields are updated in the database and that the invite code is marked as used.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Bad Request (400) Test for Duplicate Username on PUT /bind",
            "description": "Write a test to ensure the `/bind` endpoint correctly handles requests with a username that is already taken.",
            "dependencies": [
              "19.1"
            ],
            "details": "In `tests/api/v1/test_phase2_endpoints.py`, create `test_bind_user_duplicate_username`. The setup involves creating two users. The first user already has a username. The test will use the token of the second user to attempt to bind with the first user's username. Make a PUT request to `/api/v1/bind` with the duplicate username. Assert that the status code is 400 and that the response body contains a specific error message or code indicating the username is already in use.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Bad Request (400) Tests for Invalid and Used Invite Codes on PUT /bind",
            "description": "Write tests to ensure the `/bind` endpoint rejects requests with invalid or already used invite codes.",
            "dependencies": [
              "19.1"
            ],
            "details": "In `tests/api/v1/test_phase2_endpoints.py`, create two tests. First, `test_bind_user_invalid_invite_code`: use an authenticated user's token to make a PUT request to `/api/v1/bind` with an invite code that does not exist in the database. Assert a 400 status code and a relevant error message. Second, `test_bind_user_used_invite_code`: create an invite code, mark it as used in the database, and then attempt to bind with it. Assert a 400 status code and a specific error message for a used code.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 20,
        "title": "Update API Documentation",
        "description": "Update the project's API documentation (e.g., Swagger/OpenAPI) to reflect the addition of the new endpoints.",
        "details": "Since FastAPI automatically generates OpenAPI documentation from code, this task involves reviewing the generated docs at `/docs`. Ensure that the descriptions, request bodies, and response models for `GET /initState` and `PUT /bind` are clear, accurate, and helpful for API consumers. Add or refine docstrings in the router functions as needed to improve the documentation.",
        "testStrategy": "Navigate to the auto-generated Swagger UI and visually inspect the documentation for the two new endpoints. Verify that all parameters, headers, and response codes specified in the PRD are correctly documented.",
        "priority": "low",
        "dependencies": [
          17,
          18
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Docstring and Summary to GET /initState Endpoint",
            "description": "Enhance the documentation for the `GET /initState` endpoint by adding a detailed docstring to its function and a concise summary in the decorator.",
            "dependencies": [],
            "details": "In `moneynote/api/v1/endpoints/auth.py`, locate the `init_state` function. Add a Python docstring that explains its purpose: to create a temporary guest user and return an initial state object containing the guest user's details and an authentication token. Also, add a `summary` argument to the `@router.get` decorator, for example: `summary=\"Create Guest User and Get Initial State\"`.",
            "status": "pending",
            "testStrategy": "After implementation, run the app and check the `/docs` page. The `GET /initState` endpoint should have a clear summary and a detailed description section."
          },
          {
            "id": 2,
            "title": "Add Docstring and Summary to PUT /bind Endpoint",
            "description": "Enhance the documentation for the `PUT /bind` endpoint by adding a detailed docstring to its function and a concise summary in the decorator.",
            "dependencies": [],
            "details": "In `moneynote/api/v1/endpoints/auth.py`, locate the `bind_user` function. Add a Python docstring explaining that this endpoint converts the current guest user (identified by the auth token) into a permanent user by binding them to a username, password, and a valid invite code. Add a `summary` argument to the `@router.put` decorator, for example: `summary=\"Bind Guest User to a Permanent Account\"`.",
            "status": "pending",
            "testStrategy": "After implementation, run the app and check the `/docs` page. The `PUT /bind` endpoint should have a clear summary and a detailed description section."
          },
          {
            "id": 3,
            "title": "Add Field Descriptions to InitStateResponse Schema",
            "description": "Improve the clarity of the `GET /initState` response model by adding descriptions to its fields.",
            "dependencies": [],
            "details": "In `moneynote/schemas/auth.py`, find the `InitStateResponse` Pydantic model. Use `pydantic.Field` to add a `description` for each field. For the `user` field, describe it as 'The newly created guest user object.' For the `token` field, describe it as 'The JWT access token for authenticating subsequent requests for the guest user.'",
            "status": "pending",
            "testStrategy": "Check the `/docs` page for the `GET /initState` endpoint. In the 'Responses' section, expand the schema for the 200 response and verify that the descriptions for `user` and `token` are displayed."
          },
          {
            "id": 4,
            "title": "Add Field Descriptions to UserBind Schema",
            "description": "Improve the clarity of the `PUT /bind` request body model by adding descriptions to its fields.",
            "dependencies": [],
            "details": "In `moneynote/schemas/auth.py`, find the `UserBind` Pydantic model. Use `pydantic.Field` to add a `description` for each field. Describe `username`, `password`, and `invite_code` clearly, explaining their purpose and any constraints (e.g., 'A valid, unused invite code.').",
            "status": "pending",
            "testStrategy": "Check the `/docs` page for the `PUT /bind` endpoint. In the 'Request body' section, expand the schema and verify that the descriptions for `username`, `password`, and `invite_code` are displayed."
          },
          {
            "id": 5,
            "title": "Final Review and Verification of Generated API Docs",
            "description": "Perform a final review of the auto-generated Swagger/OpenAPI documentation to ensure all recent changes are correctly reflected and the documentation is clear, accurate, and helpful.",
            "dependencies": [
              "20.1",
              "20.2",
              "20.3",
              "20.4"
            ],
            "details": "Run the FastAPI application locally. Open a web browser and navigate to the `/docs` URL. Systematically review the endpoints for `GET /initState` and `PUT /bind`. Verify that: 1. The summaries are present and correct. 2. The detailed descriptions from the docstrings are visible. 3. The request body schema for `/bind` has field descriptions. 4. The response schema for `/initState` has field descriptions. 5. The overall presentation is professional and easy for an API consumer to understand.",
            "status": "pending",
            "testStrategy": "Visually confirm that all documentation elements added in the previous subtasks are rendered correctly in the Swagger UI. Try the 'Try it out' feature to ensure the example values and schemas match expectations."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-21T09:07:27.806Z",
      "updated": "2025-10-28T06:30:10.212Z",
      "description": "Tasks for master context"
    }
  }
}