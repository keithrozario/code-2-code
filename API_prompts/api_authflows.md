

Here is a detailed analysis of the authentication and authorization processes in the moneynote-api repository.

| Feature | Step-by-step Explanation | Code Snippets |
| :--- | :--- | :--- |
| **`POST /login` Authentication** | 1. The `UserController` receives the login request containing the username and password. <br> 2. It calls the `UserService.login()` method to handle the authentication logic. <br> 3. In `UserService`, the user is fetched from the database by username. <br> 4. The `PasswordEncoder` is used to securely compare the provided password with the stored hashed password. <br> 5. If the credentials are valid, a JWT is generated by `JwtUtils.createToken()`. <br> 6. The JWT payload contains the `userId` and an expiration time of 30 days. The token is signed with a hardcoded secret key. <br> 7. The generated token is returned in the response and also stored in the HTTP session. | `UserController.java`:<br>```java<br>@RequestMapping(method = RequestMethod.POST, value = "/login")<br>public BaseResponse handleLogin(@Valid @RequestBody LoginForm request) {<br>    var result = userService.login(request);<br>    httpServletRequest.getSession().setAttribute("accessToken", result.getAccessToken());<br>    return new DataMessageResponse<>(result, messageSourceUtil.getMessage("user.login.success"));<br>}<br>```<br>`UserService.java`:<br>```java<br>public LoginResponse login(LoginForm form) {<br>    User user = userRepository.findOneByUsername(form.getUsername()).orElse(null);<br>    if (user == null || !passwordEncoder.matches(form.getPassword(), user.getPassword())) {<br>        throw new FailureMessageException("user.login.wrong.credentials");<br>    }<br>    String jwt = jwtUtils.createToken(user);<br>    // ...<br>}<br>```<br>`JwtUtils.java`:<br>```java<br>public String createToken(User user) {<br>    return JWT.create().withSubject(user.getId().toString())<br>            .withClaim("userId", user.getId())<br>            .withExpiresAt(Instant.now().plus(Duration.ofDays(30))) //30天之后过期<br>            .sign(Algorithm.HMAC256(secretKey));<br>}<br>``` |
| **`PUT /accounts/{id}` Authorization** | 1. The `AuthInterceptor` intercepts the incoming request before it reaches the `AccountController`. <br> 2. The interceptor extracts the JWT from the `Authorization` header or the HTTP session. <br> 3. The `JwtUtils.getUserId()` method verifies the token's signature and extracts the `userId` from the payload. <br> 4. The user is fetched from the database, and the `CurrentSession` object is populated with the user's details, including their default group and book. <br> 5. The request proceeds to the `AccountController.handleUpdate()` method. <br> 6. Inside `AccountService.update()`, the `sessionUtil.getCurrentGroup()` method is called to get the user's current group. <br> 7. The `baseService.findAccountById(id)` method is called to fetch the account. This service likely contains the core authorization logic, ensuring that the requested account belongs to the user's current group. <br> 8. If the user is authorized, the account is updated. Otherwise, an exception would be thrown. | `MvcInterceptorConfig.java`:<br>```java<br>registry.addInterceptor(authInterceptor)<br>        .addPathPatterns("/**")<br>        .excludePathPatterns("/login", "/register")<br>        // ...<br>```<br>`AuthInterceptor.java`:<br>```java<br>public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {<br>    // ... token resolution and validation ...<br>    User user = userRepository.findById(jwtUtils.getUserId(token)).orElseThrow(/*...*/);<br>    // ... populate CurrentSession ...<br>    return true;<br>}<br>```<br>`AccountService.java`:<br>```java<br>public boolean update(Integer id, AccountUpdateForm form) {<br>    Group group = sessionUtil.getCurrentGroup();<br>    Account entity = baseService.findAccountById(id);<br>    if (!entity.getName().equals(form.getName())) {<br>        if (StringUtils.hasText(form.getName())) {<br>            if (accountRepository.existsByGroupAndName(group, form.getName())) {<br>                throw new ItemExistsException();<br>            }<br>        }<br>    }<br>    AccountMapper.updateEntity(form, entity);<br>    accountRepository.save(entity);<br>    return true;<br>}<br>``` |
