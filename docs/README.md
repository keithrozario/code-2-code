# Moneynote Docs


## Customized reports

The two reports that begin with 'customized' are generated by the following codemod commands.

## User Journeys

Generated by the `gen_user_j.py` file using the following prompt:

```
    Look at the {code_mod_report}.md file, and the {code_mod_report_data_layer} file. 
    These files represent a report for code in moneynote-api directory. 
    As a senior business analyst Document {user_journey_name}. Document your results in an .md file with the following content:

1. Detailed User Journeys and Flows

Objective: To capture the step-by-step interactions a user has with the system to achieve a specific business goal.
Requirements:
    *   Document each distinct and significant user journey.
    *   For each journey, provide a clear, sequential description of user actions and system responses.
    *   Include decision points, alternative paths, and error handling scenarios within the flow.
    *   Visual representation (e.g., flowcharts, sequence diagrams) is highly encouraged to illustrate the flow.
    *   Clearly identify the start and end points of each journey.
    *   If multiple journeys lead to similar outcomes with variations, document these variations.

2. Detailed Object Level Data Structures**

Objective: To meticulously document the structure and attributes of key data entities within the system.
Requirements:
    *   Identify and list all significant data entities (e.g., Customer, Order, Product, Invoice, User Account).
    *   For each entity, list all its data attributes as they exist in the code or database.
    *   For each attribute, capture:
        *   Attribute Name (exact name from code/database).
        *   Data Type (e.g., `string`, `integer`, `boolean`, `datetime`, `decimal`, `enum`, `complex_object`).
        *   Constraints or Properties (e.g., `NOT NULL`, `UNIQUE`, `PRIMARY KEY`, `FOREIGN KEY`, `maxLength`, `defaultValue`, `isEncrypted`).
        *   A brief description of what the attribute represents.
    *   Indicate relationships between entities where relevant (e.g., One-to-Many, Many-to-Many).

3. Database Tables to be Updated

Objective: To identify which database tables are directly impacted by user actions and system processes.
Requirements:
    *   For each documented user journey and major functional area, list the specific database tables that are:
        *   Read from (e.g., for data retrieval).
        *   Written to (e.g., `INSERT`, `UPDATE`, `DELETE` operations).
    *   Specify the typical operations performed on each table within the context of the documented functionality.

4. Business Rules and Functionality (Detailed)

Objective: To capture the explicit and implicit logic that governs the system's behavior and data integrity.
Requirements:
    *   Provide a detailed description of all identified business rules.
    *   For each rule, specify:
        *   Rule Name/Identifier: A concise name for the rule.
        *   Description: A clear explanation of the rule.
        *   Triggering Event: What action or condition initiates this rule?
        *   Logic/Conditions: The specific criteria, calculations, or conditional statements involved.
        *   Outcome/Action: What happens when the rule is met or violated?
    *   Validations (Front-end and Back-end):
        *   Front-end Validations: Detail any checks performed on the user interface to guide user input and provide immediate feedback (e.g., "required field," "email format," "numeric range").
        *   Back-end Validations: Detail any checks performed on the server-side to ensure data integrity, security, and adherence to business logic (e.g., "inventory check," "user permissions," "data consistency checks"). For each validation, describe the rule being enforced and the consequence of failure.

5. Detailed Test Cases

Objective: To create a comprehensive set of test cases that can verify the correct implementation of user journeys and business rules.
Requirements:
    *   Develop detailed test cases for each significant user journey and business rule.
    *   Each test case should include:
        *   Test Case ID: A unique identifier.
        *   Feature/User Story/Rule Being Tested:** Clear reference to the item under test.
        *   Preconditions: Any setup required before executing the test.
        *   Test Steps: A precise, sequential list of actions to perform.
        *   Test Data: Specific input data required for the test.
        *   Expected Result: The anticipated outcome of performing the test steps with the given data.
    *   Include test cases for:
        *   Happy Paths: Valid scenarios.
        *   Negative Paths: Invalid inputs and error conditions.
        *   Boundary Conditions: Testing limits and edge cases of data inputs.
        *   Error Handling: Verifying how the system responds to exceptions and invalid states.

6. State Any Assumptions

Objective: To document any assumptions made during the extraction process due to ambiguity or lack of definitive information.
Requirements:
    *   List all assumptions clearly and concisely.
    *   For each assumption, explain the reasoning or the gap in information that led to it.
    *   These assumptions are critical for understanding the context and potential areas for further investigation.


Generate the output to markdown, and save the file to the following absolute path {file_name} file.
```

## Next Step:

Generate a Detail Technical documentation with these files:

The Detail technical documentation should have:

### Data Architecture

* Complete data model
* Each table, with description
* Column of table, with description and Type
* FK, PK of Each Table
* Do not need physical architecture for now.

### Application Architecture

* The technical stack of the Application
* Backend, Frontend, and Database
* The Backend stack
  * Language and Framework (assume Python and FastApi)
  * What package management is used (assume uv)
* The Frontend
  * Framework used (assume react for now)

### API Design

* Detail each API
* Include each endpoint e.g. `/api/v1/accounts`, with the both the requests and response.
* For each requests and response include the data attributes and types
* Assume the response/request bodies are all in JSON

### Frontend design

* Detail the front-end stack
* Detail each screen
* Detail each component (button, form, field) of each screen

### Infra architecture
* Detail the backend infrastructure (where will the app be deployed, refer to codmod report for this)
* Detail the networking architecture (assuming its connected to the internet )
  * Load Balancers and CDN

### Security Architecture
* Authentication and Authorization
* Web application firewall

### assumptions
* State all assumption


Doc Structure:
├── docs/
   └── cod_mod_reports/
      └── cod_mod_functional_user_journeys.md
      └── cod_mod_data_layer.md
   └── context_docs/
      └── context_doc_1
      └── context_doc_2
      └── context_doc_n....
   └── user_journeys/
      └── user_journey_1
      └── user_journey_2
      └── user_journey_n ....
   └── database_design/
      └── database_definition.md
   └── api_design/
      └── api-dependencies.md
      └── api-definition.md
   └── front_end_design/
      └── fe_design.md
   └── infra_design/
      └── infra_design.md
   └── security_design/
      └── security_design.md